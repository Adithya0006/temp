Good ðŸ”¥ Youâ€™re learning MUI seriously â€” I like this approach.

Hereâ€™s a clean, reusable global dropdown template using React + MUI that:

âœ… Fetches options from API

âœ… Displays them in dropdown

âœ… Calls another API when value is selected

âœ… Fully reusable component

âœ… Uses sx for styling

âœ… Works with dummy API for now



---

âœ… 1ï¸âƒ£ Global Reusable Dropdown Component

ðŸ“ components/ApiSelect.jsx

import React, { useEffect, useState } from "react";
import {
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  CircularProgress,
  FormHelperText,
} from "@mui/material";
import axios from "axios";

const ApiSelect = ({
  label = "Select Option",
  fetchUrl,
  onSelectApi,
  valueKey = "id",
  labelKey = "name",
  sx = {},
  fullWidth = true,
}) => {
  const [options, setOptions] = useState([]);
  const [selected, setSelected] = useState("");
  const [loading, setLoading] = useState(false);

  // ðŸ”¹ Fetch dropdown values from API
  useEffect(() => {
    const fetchOptions = async () => {
      try {
        setLoading(true);
        const res = await axios.get(fetchUrl);
        setOptions(res.data);
      } catch (err) {
        console.error("Error fetching dropdown data", err);
      } finally {
        setLoading(false);
      }
    };

    fetchOptions();
  }, [fetchUrl]);

  // ðŸ”¹ When user selects option
  const handleChange = async (event) => {
    const value = event.target.value;
    setSelected(value);

    if (onSelectApi) {
      try {
        await axios.get(`${onSelectApi}/${value}`);
        console.log("Second API called with:", value);
      } catch (err) {
        console.error("Error calling select API", err);
      }
    }
  };

  return (
    <FormControl fullWidth={fullWidth} sx={{ minWidth: 220, ...sx }}>
      <InputLabel>{label}</InputLabel>

      <Select
        value={selected}
        label={label}
        onChange={handleChange}
      >
        {loading ? (
          <MenuItem disabled>
            <CircularProgress size={20} />
          </MenuItem>
        ) : (
          options.map((item) => (
            <MenuItem
              key={item[valueKey]}
              value={item[valueKey]}
            >
              {item[labelKey]}
            </MenuItem>
          ))
        )}
      </Select>

      {loading && <FormHelperText>Loading options...</FormHelperText>}
    </FormControl>
  );
};

export default ApiSelect;


---

âœ… 2ï¸âƒ£ How to Use It Anywhere

ðŸ“ App.jsx

import React from "react";
import ApiSelect from "./components/ApiSelect";

const App = () => {
  return (
    <div style={{ padding: "40px" }}>
      <ApiSelect
        label="Select User"
        fetchUrl="https://jsonplaceholder.typicode.com/users"
        onSelectApi="https://jsonplaceholder.typicode.com/posts"
        valueKey="id"
        labelKey="name"
        sx={{
          backgroundColor: "#fff",
          borderRadius: 2,
          boxShadow: 3,
        }}
      />
    </div>
  );
};

export default App;


---

âœ… How It Works

ðŸ”¹ Step 1

Calls:

https://jsonplaceholder.typicode.com/users

Loads users into dropdown.

ðŸ”¹ Step 2

When selecting user with id = 3
It calls:

https://jsonplaceholder.typicode.com/posts/3

(Just dummy call for now)


---

ðŸ§  Why This Is Production Level

Fully reusable

No hardcoded API

Works for any backend response

Dynamic keys (valueKey, labelKey)

Clean separation of logic

Easy to scale



---

ðŸ”¥ Upgrade Version (Better Architecture for You)

If you want it even more professional:

Instead of passing onSelectApi URL, pass a function:

onSelect={(value) => callYourApi(value)}

This gives full flexibility.


---

If you want, next I can give:

ðŸ”¥ Version with debounce

ðŸ”¥ Version with Autocomplete

ðŸ”¥ Version with dependent dropdown (Country â†’ State)

ðŸ”¥ Version integrated with React Hook Form

ðŸ”¥ Version with loading skeleton


Tell me which level you want ðŸ˜Ž
