@app.post("/supervisor/assign")
def supervisor_assign(
    request: Request,
    supervisor_staff_no: str = Query(...),
    pcb_serial_parts: List[str] = Query(None, alias="pcb_serial_parts[]"),
    db: Session = Depends(init_db)
):
    """
    Supervisor Assignment Endpoint

    Supports:
    - Fresh CHILD assignment
    - Fresh MAIN assignment
    - MAIN continuation after CHILD completed
    - Safe reopening of workflow
    - Duplicate step protection
    """

    # =========================================================
    # 1Ô∏è‚É£ Extract PCB List (Fallback if FastAPI fails parsing)
    # =========================================================
    if not pcb_serial_parts:
        raw_qs = request.scope.get("query_string", b"").decode()
        parsed = urllib.parse.parse_qs(raw_qs)

        pcb_serial_parts = (
            parsed.get("pcb_serial_parts[]")
            or parsed.get("pcb_serial_parts")
            or []
        )

    if not pcb_serial_parts:
        raise HTTPException(status_code=400, detail="No PCB serial numbers provided")

    # =========================================================
    # 2Ô∏è‚É£ Validate Supervisor
    # =========================================================
    supervisor = find_user_from_profiles(db, supervisor_staff_no)

    if not supervisor:
        raise HTTPException(status_code=404, detail="Supervisor not found")

    if (supervisor.userRole or "").strip().upper() not in (
        "SUPERVISOR",
        "SUPERVISOR INTERNAL",
        "SUPERVISORINTERNAL"
    ):
        raise HTTPException(status_code=403, detail="Not authorized")

    # =========================================================
    # 3Ô∏è‚É£ Load Full Process Flow
    # =========================================================
    flow = db.query(ProcessFlowMaster)\
             .order_by(ProcessFlowMaster.step_order.asc())\
             .all()

    if not flow:
        raise HTTPException(status_code=500, detail="Process flow empty")

    first_step_id = flow[0].flow_step_id

    # Find step_order = 15
    step_15_id = next(
        (s.flow_step_id for s in flow if s.step_order == 15),
        None
    )

    assign_count = 0

    # =========================================================
    # 4Ô∏è‚É£ Iterate Through Each PCB
    # =========================================================
    for raw_id in pcb_serial_parts:

        pcb = db.execute(
            select(PcbData).where(
                PcbData.PCBserialNoPartNumber == raw_id
            )
        ).scalar_one_or_none()

        if not pcb:
            continue

        pcb_type = (pcb.Type or "").strip().upper()

        # -----------------------------------------------------
        # Check Existing Assignment (even if completed)
        # -----------------------------------------------------
        existing_assignment = db.execute(
            select(PCBAssignment)
            .where(PCBAssignment.assigned_pcb_id == raw_id)
        ).scalar_one_or_none()

        # =====================================================
        # üî• CASE 1: MAIN continuation on existing assignment
        # =====================================================
        if existing_assignment and pcb_type in ("HEXA-MAIN", "OCTA-MAIN"):

            # Get all existing logs
            existing_logs = db.query(PCBProcessLog).filter(
                PCBProcessLog.assignment_id == existing_assignment.assignment_id
            ).all()

            if not existing_logs:
                continue

            existing_step_ids = {log.flow_step_id for log in existing_logs}

            # Find last created step
            last_step_id = max(existing_step_ids)

            # Find its index in master flow
            start_index = next(
                (i for i, s in enumerate(flow) if s.flow_step_id == last_step_id),
                None
            )

            if start_index is None:
                continue

            # Insert remaining steps (after last_step_id)
            inserted_steps = []

            for index, step in enumerate(flow[start_index + 1:]):

                # Prevent duplicate insertion
                if step.flow_step_id not in existing_step_ids:

                    status = "PENDING" if index == 0 else "STAGED"

                    db.add(
                        PCBProcessLog(
                            assignment_id=existing_assignment.assignment_id,
                            flow_step_id=step.flow_step_id,
                            process_status=status,
                            assigned_operator_staff_no=None
                        )
                    )

                    inserted_steps.append(step.flow_step_id)

            # -------------------------------------------------
            # üî• Reopen workflow properly
            # -------------------------------------------------
            if inserted_steps:
                existing_assignment.overall_status = "IN_PROGRESS"
                existing_assignment.current_step_id = inserted_steps[0]

                assign_count += 1

            continue

        # =====================================================
        # üîπ CASE 2: Skip if active assignment already exists
        # =====================================================
        if existing_assignment and existing_assignment.overall_status != "COMPLETED":
            continue

        # =====================================================
        # üîπ CASE 3: Fresh Assignment (CHILD or MAIN)
        # =====================================================
        if pcb_type in ("HEXA-CHILD", "OCTA-CHILD"):
            starting_step_id = first_step_id

        elif pcb_type in ("HEXA-MAIN", "OCTA-MAIN"):
            starting_step_id = step_15_id or first_step_id

        else:
            starting_step_id = first_step_id

        # Create new assignment
        new_assignment = PCBAssignment(
            supervisor_staff_no=supervisor.userID,
            assigned_pcb_id=raw_id,
            overall_status="IN_PROGRESS",
            current_step_id=starting_step_id
        )

        db.add(new_assignment)
        db.flush()

        pcb.status = "Assigned"
        db.add(pcb)

        # Insert logs from starting step
        start_index = next(
            (i for i, s in enumerate(flow) if s.flow_step_id == starting_step_id),
            0
        )

        for index, step in enumerate(flow[start_index:]):

            db.add(
                PCBProcessLog(
                    assignment_id=new_assignment.assignment_id,
                    flow_step_id=step.flow_step_id,
                    process_status="PENDING" if index == 0 else "STAGED",
                    assigned_operator_staff_no=None
                )
            )

        assign_count += 1

    # =========================================================
    # 5Ô∏è‚É£ Commit Transaction
    # =========================================================
    db.commit()

    return {
        "assigned": assign_count,
        "message": "Assignment processed successfully"
    }












from fastapi import HTTPException, Depends
from sqlalchemy.orm import Session
from datetime import datetime


@app.post("/operator/updatestatus")
def update_status(req: OperatorActionRequest, db: Session = Depends(init_db)):

    # ---------------------------------------------------------
    # 1Ô∏è‚É£ Validate Operator
    # ---------------------------------------------------------
    operator = normalize_staff(req.operator_staff_no)
    profile = find_user_from_profiles(db, operator)

    if not profile:
        raise HTTPException(status_code=404, detail="Operator not found")

    # ---------------------------------------------------------
    # 2Ô∏è‚É£ Fetch Current PCB Process Log
    # ---------------------------------------------------------
    log = db.query(PCBProcessLog).filter(
        PCBProcessLog.assignment_id == req.assignment_id,
        PCBProcessLog.flow_step_id == req.current_step_id
    ).first()

    if not log:
        raise HTTPException(status_code=404, detail="Task not found for this PCB")

    # ---------------------------------------------------------
    # 3Ô∏è‚É£ Validate Operator Eligibility
    # ---------------------------------------------------------
    allowed = db.query(OperatorStepMapping).filter(
        OperatorStepMapping.flow_step_id == log.flow_step_id,
        OperatorStepMapping.operator_staff_no == operator
    ).first()

    if not allowed:
        raise HTTPException(status_code=403, detail="Operator not allowed for this task")

    # ---------------------------------------------------------
    # 4Ô∏è‚É£ Fetch Assignment
    # ---------------------------------------------------------
    assignment = db.query(PCBAssignment).filter(
        PCBAssignment.assignment_id == req.assignment_id
    ).first()

    if not assignment:
        raise HTTPException(status_code=404, detail="Assignment not found")

    # Prevent updates if already closed
    if assignment.overall_status == "COMPLETED":
        raise HTTPException(status_code=400, detail="PCB workflow already completed")

    # ---------------------------------------------------------
    # 5Ô∏è‚É£ Save / Update Operator Audit Log
    # ---------------------------------------------------------
    operator_details = db.query(OperatorStepMapping).filter(
        OperatorStepMapping.operator_staff_no == operator
    ).first()

    ope_log = db.query(OperatorLog).filter(
        OperatorLog.PCBserialNoPartNumber == req.PCBserialNoPartNumber,
        OperatorLog.current_step_id == req.current_step_id
    ).first()

    if not ope_log:
        operator_log = OperatorLog(
            PCBserialNoPartNumber=req.PCBserialNoPartNumber,
            current_step_id=req.current_step_id,
            assignment_id=req.assignment_id,
            Task_Status=req.Task_Status,
            Task_Name=req.Task_Name,
            operator_staff_no=operator,
            log_Data=req.log_Data,
            operator_name=operator_details.operator_name,
            operator_initial=operator_details.operator_initial,
            operator_MRL=operator_details.operator_MRL,
            operator_MRL_Expiry=operator_details.operator_MRL_Expiry,
            userID=req.userID,
            userName=req.userName,
            userRole=req.userRole,
            userSBU=req.userSBU,
            userSBUDiv=req.userSBUDiv,
            start_time=req.start_time,
            end_time=req.end_time
        )
        db.add(operator_log)
    else:
        ope_log.Task_Status = req.Task_Status
        ope_log.log_Data = req.log_Data
        ope_log.end_time = req.end_time

    # ---------------------------------------------------------
    # 6Ô∏è‚É£ Action Handling
    # ---------------------------------------------------------
    action = req.Task_Status.upper()

    # ============================
    # START
    # ============================
    if action == "STARTED":

        if log.process_status not in ("PENDING", "PAUSED"):
            raise HTTPException(
                status_code=400,
                detail="Step not ready to start"
            )

        if log.process_status == "STARTED":
            raise HTTPException(
                status_code=400,
                detail="Step already started"
            )

        log.start_time = datetime.utcnow()
        log.process_status = "STARTED"
        log.assigned_operator_staff_no = operator
        assignment.current_step_id = log.flow_step_id

    # ============================
    # PAUSE
    # ============================
    elif action == "PAUSE":

        if log.process_status != "STARTED":
            raise HTTPException(
                status_code=400,
                detail="Cannot pause a step that is not started"
            )

        log.process_status = "PAUSED"

    # ============================
    # COMPLETE
    # ============================
    elif action == "COMPLETED":

        if log.process_status not in ("STARTED", "PAUSED"):
            raise HTTPException(
                status_code=400,
                detail="Step must be started before completing"
            )

        log.end_time = datetime.utcnow()
        log.process_status = "COMPLETED"

        # Get master flow step
        step = db.get(ProcessFlowMaster, log.flow_step_id)

        if not step:
            raise HTTPException(
                status_code=500,
                detail="Process flow configuration error"
            )

        # üî• IMPORTANT FIX:
        # Check if NEXT PCBProcessLog exists in this assignment
        next_log = None

        if step.next_step_id:
            next_log = db.query(PCBProcessLog).filter(
                PCBProcessLog.assignment_id == log.assignment_id,
                PCBProcessLog.flow_step_id == step.next_step_id
            ).first()

        # ------------------------------------------
        # If NO next_log exists ‚Üí CLOSE PCB
        # (CHILD scenario restriction)
        # ------------------------------------------
        if not next_log:
            assignment.overall_status = "COMPLETED"
            assignment.current_step_id = None
            db.commit()

            return {
                "message": "Final stage completed. PCB restricted.",
                "current_step_id": None,
                "pcb": req.PCBserialNoPartNumber
            }

        # ------------------------------------------
        # Otherwise ‚Üí Activate Next Step (MAIN case)
        # ------------------------------------------
        if next_log.process_status == "STAGED":
            next_log.process_status = "PENDING"

        assignment.current_step_id = step.next_step_id

    else:
        raise HTTPException(status_code=400, detail="Invalid Task_Status")

    # ---------------------------------------------------------
    # 7Ô∏è‚É£ Commit Changes
    # ---------------------------------------------------------
    db.commit()

    return {
        "message": "Status updated successfully",
        "current_step_id": assignment.current_step_id,
        "pcb": req.PCBserialNoPartNumber
    }








