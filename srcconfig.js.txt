
@app.post("/operator/updatestatus")
def update_status(req: OperatorActionRequest, db: Session = Depends(get_db)):

    # -----------------------------
    # 1️⃣ Validate operator
    # -----------------------------
    operator = normalize_staff(req.operator_staff_no)
    profile = find_user_from_profiles(db, operator)
    if not profile:
        raise HTTPException(status_code=404, detail="Operator not found")

    # -----------------------------
    # 2️⃣ Fetch PCB process log (CURRENT STEP)
    # -----------------------------
    log = db.query(PCBProcessLog).filter(
        PCBProcessLog.assignment_id == req.assignment_id,
        PCBProcessLog.flow_step_id == req.current_step_id
    ).first()

    if not log:
        raise HTTPException(status_code=404, detail="Task not found for this PCB")

    # -----------------------------
    # 3️⃣ Validate operator eligibility
    # -----------------------------
    allowed = db.query(OperatorStepMapping).filter(
        OperatorStepMapping.flow_step_id == log.flow_step_id,
        OperatorStepMapping.operator_staff_no == operator
    ).first()

    if not allowed:
        raise HTTPException(status_code=403, detail="Operator not allowed for this task")

    # -----------------------------
    # 4️⃣ Fetch assignment
    # -----------------------------
    assignment = db.query(PCBAssignment).filter(
        PCBAssignment.assignment_id == req.assignment_id
    ).first()

    if not assignment:
        raise HTTPException(status_code=404, detail="Assignment not found")

    # -----------------------------
    # 5️⃣ Save operator activity log (AUDIT)
    # -----------------------------
    operator_details = db.query(OperatorStepMapping).filter(OperatorStepMapping.operator_staff_no==operator).first()
    ope_log = db.query(OperatorLog).filter(OperatorLog.PCBserialNoPartNumber==req.PCBserialNoPartNumber, OperatorLog.current_step_id==req.current_step_id).first()

    if not ope_log:
        operator_log = OperatorLog(
            PCBserialNoPartNumber=req.PCBserialNoPartNumber,
            current_step_id=req.current_step_id,
            assignment_id=req.assignment_id,
            Task_Status=req.Task_Status,
            Task_Name=req.Task_Name,
            operator_staff_no=operator,
            log_Data=req.log_Data,
            operator_name = operator_details.operator_name,
            operator_initial = operator_details.operator_initial,
            operator_MRL = operator_details.operator_MRL,
            operator_MRL_Expiry= operator_details.operator_MRL_Expiry,
            userID=req.userID,
            userName=req.userName,
            userRole=req.userRole,
            userSBU=req.userSBU,
            userSBUDiv=req.userSBUDiv,
            start_time=req.start_time,
            end_time=req.end_time
        )
        db.add(operator_log)
    else:
        ope_log.PCBserialNoPartNumber=req.PCBserialNoPartNumber
        ope_log.current_step_id=req.current_step_id
        ope_log.assignment_id=req.assignment_id
        ope_log.Task_Status=req.Task_Status
        ope_log.Task_Name=req.Task_Name
        ope_log.operator_staff_no=operator
        ope_log.log_Data=req.log_Data
        ope_log.userID=req.userID
        ope_log.userName=req.userName
        ope_log.userRole=req.userRole
        ope_log.userSBU=req.userSBU
        ope_log.userSBUDiv=req.userSBUDiv
        ope_log.end_time=req.end_time

    # -----------------------------
    # 6️⃣ Action handling
    # -----------------------------
    action = req.Task_Status.upper()

    if action == "STARTED":
        log.start_time = datetime.utcnow()
        log.process_status = "STARTED"
        log.assigned_operator_staff_no = operator

        # ⭐ IMPORTANT: update current step immediately
        assignment.current_step_id = log.flow_step_id

    elif action == "PAUSE":
        log.process_status = "PAUSED"

    elif action == "COMPLETED":
        log.end_time = datetime.utcnow()
        log.process_status = "COMPLETED"

        step = db.get(ProcessFlowMaster, log.flow_step_id)

        if not step or not step.next_step_id:
            # Last step → close PCB
            assignment.overall_status = "COMPLETED"
            assignment.current_step_id = None
            db.commit()
            return {"message": "Final step completed. PCB workflow closed."}

        # Activate next step
        next_log = db.query(PCBProcessLog).filter(
            PCBProcessLog.assignment_id == log.assignment_id,
            PCBProcessLog.flow_step_id == step.next_step_id
        ).first()

        if next_log:
            next_log.process_status = "PENDING"


        assignment.current_step_id = step.next_step_id

    else:
        raise HTTPException(status_code=400, detail="Invalid Task_Status")

    db.commit()

    return {
        "message": "Status updated successfully",
        "current_step_id": assignment.current_step_id,
        "pcb": req.PCBserialNoPartNumber
    }



# ---------------------------------------------------------
# ⭐ NEW ENDPOINT: Get Last Log for Copy/Paste Functionality
# ---------------------------------------------------------
@app.get("/operator/last-log")
def get_last_operator_log(staff_no: str, stage_id: int, db: Session = Depends(get_db)):
    # Normalize staff number if your system requires it
    operator = normalize_staff(staff_no) 
    
    # Query the Audit Log for the most recent entry by this operator for this stage
    last_log = db.query(OperatorLog).filter(
        OperatorLog.operator_staff_no == operator,
        OperatorLog.current_step_id == stage_id,
        OperatorLog.log_Data.isnot(None) # Ensure we only get logs with data
    ).order_by(desc(OperatorLog.end_time)).first()

    if not last_log:
        return {"log_Data": None, "message": "No previous data found"}

    return {"log_Data": last_log.log_Data}


# ---------------------------------------------------------
# ⭐ NEW ENDPOINT: Get Log by Serial Number (Search)
# ---------------------------------------------------------
@app.get("/operator/log-by-serial")
def get_log_by_serial(target_serial: str, stage_id: int, db: Session = Depends(get_db)):
    """
    Fetches the log data for a SPECIFIC PCB at a specific stage.
    """
    # We strip whitespace to avoid matching errors
    target = target_serial.strip()

    # Query the OperatorLog for this specific PCB and Stage
    target_log = db.query(OperatorLog).filter(
        OperatorLog.PCBserialNoPartNumber == target,
        OperatorLog.current_step_id == stage_id,
        OperatorLog.log_Data.isnot(None)
    ).order_by(desc(OperatorLog.end_time)).first() # Get most recent if duplicates exist

    if not target_log:
        return {"log_Data": None, "message": "No data found for this Serial Number"}

    return {"log_Data": target_log.log_Data}
