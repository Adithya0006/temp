
@app.get("/operatordashboard")
def operator_view(staff_no: str, db: Session = Depends(init_db)):
    staff = normalize_staff(staff_no)
    user = find_user_from_profiles(db, staff)
    if not user:
        raise HTTPException(status_code=404, detail="Operator not found")

    # 1. Fetch History for the Productivity Chart (Specific to this Operator)
    history_records = db.query(OperatorLog).filter(
        OperatorLog.operator_staff_no == staff,
        OperatorLog.Task_Status == "Completed"
    ).order_by(desc(OperatorLog.end_time)).limit(50).all()

    operator_history = []
    for log in history_records:
        operator_history.append({
            "stageName": log.Task_Name,
            "completedAt": log.end_time.isoformat() if log.end_time else None
        })

    # 2. Traceability: Fetch status of EVERY PCB currently in the assembly line
    # (Requirement: "entire assembly line", not just for this operator)
    all_active_pcbs = db.execute(
        select(PCBAssignment, PcbData, ProcessFlowMaster)
        .join(PcbData, PcbData.PCBserialNoPartNumber == PCBAssignment.assigned_pcb_id)
        .join(ProcessFlowMaster, ProcessFlowMaster.flow_step_id == PCBAssignment.current_step_id)
        .where(PCBAssignment.overall_status == "IN_PROGRESS")
    ).all()

    traceability_data = []
    for assignment, pcb, step in all_active_pcbs:
        traceability_data.append({
            "serialNo": pcb.serialNo,
            "partNumber": pcb.partNumber,
            "currentStage": step.step_name,
            "stageId": step.flow_step_id,
            "assignedDate": assignment.assignment_date
        })

    # 3. Existing Operator-Specific Logic for "My Tasks"
    qualified_step_ids = db.execute(
        select(OperatorStepMapping.flow_step_id)
        .where(OperatorStepMapping.operator_staff_no == user.userID)
    ).scalars().all()

    # Get active assignments where the current step matches operator's qualifications
    result = []
    for assignment, pcb, step in all_active_pcbs:
        if assignment.current_step_id in qualified_step_ids:
            # Fetch detailed task logs for the Execute view
            logs = db.execute(
                select(PCBProcessLog, ProcessFlowMaster, OperatorLog)
                .join(ProcessFlowMaster, PCBProcessLog.flow_step_id == ProcessFlowMaster.flow_step_id)
                .outerjoin(OperatorLog, and_(
                     PCBProcessLog.flow_step_id == OperatorLog.current_step_id, 
                     PCBProcessLog.assignment_id == OperatorLog.assignment_id,
                     OperatorLog.operator_staff_no == staff
                ))
                .where(PCBProcessLog.assignment_id == assignment.assignment_id)
                .where(PCBProcessLog.flow_step_id.in_(qualified_step_ids))
            ).all()

            task_list = []
            for log, s, o_log in logs:
                task_list.append({
                    "flowStepId": s.flow_step_id,
                    "processName": s.step_name,
                    "status": log.process_status,
                    "operator_Json_log": o_log.log_Data if o_log else None
                })

            result.append({
                "serialNo": pcb.serialNo,
                "currentStepId": assignment.current_step_id,
                "processName": step.step_name,
                "assignmentid": assignment.assignment_id,
                "tasks": task_list
            })

    return {
        "operator": user.username,
        "operator_id": user.userID,
        "Productivity_History": operator_history,
        "Assembly_Line_Traceability": traceability_data, 
        "pcbs": result
    }
