

def format_step_data(step_obj) -> StepDetail:
    """
    Helper to convert a ProcessFlowMaster SQLAlchemy object 
    into a Pydantic schema (StepDetail).
    """
    if not step_obj:
        return None
        
    operators = [
        OperatorInfo(
            operator_staff_no=op.operator_staff_no,
            operator_name=op.operator_name,
            operator_MRL=op.operator_MRL
        ) for op in step_obj.qualified_operators
    ]
    
    return StepDetail(
        step_id=step_obj.flow_step_id,
        step_order=step_obj.step_order,
        step_name=step_obj.step_name,
        qualified_operators=operators
    )


#######################################################################################

@app.get("/pcb-process-tracking", response_model=List[PCBProcessStatus])
def get_pcb_process_tracking(db: Session = Depends(get_db)):
  """
  Retrieves all assigned PCBs with their current, previous (3), and next (3) process steps
  and the operators qualified to perform them.
  """
 
  # 1. Fetch Process Master Data (Cached lookup)
  # We fetch all steps and operators once to avoid N+1 queries inside the loop.
  all_steps = (
    db.query(ProcessFlowMaster)
    .options(joinedload(ProcessFlowMaster.qualified_operators))
    .order_by(ProcessFlowMaster.step_order)
    .all()
  )
 
  # Create a lookup dictionary to find a step's index in the sorted list by its ID
  # key: flow_step_id, value: index in the all_steps list
  step_index_map = {step.flow_step_id: i for i, step in enumerate(all_steps)}

  # 2. Fetch Assignments joined with PCB Data
  # We need PcbData for the 'serialNo' and Assignment for 'current_step_id'
  results = (
    db.query(PCBAssignment, PcbData)
    .join(PcbData, PCBAssignment.assigned_pcb_id == PcbData.PCBserialNoPartNumber)
    .all()
  )

  response_data = []

  for assignment, pcb in results:
    current_step_id = assignment.current_step_id
   
    # Initialize default values
    current_step_obj = None
    current_step_idx = -1
   
    # Find where the current step sits in the master flow
    if current_step_id in step_index_map:
      current_step_idx = step_index_map[current_step_id]
      current_step_obj = all_steps[current_step_idx]

    # --- Logic for Previous / Next Windows ---
    prev_steps_data = []
    next_steps_data = []

    if current_step_idx != -1:
      # Get Previous 3 (slicing handles bounds automatically)
      # If index is 5, we want indices 2, 3, 4.
      start_prev = max(0, current_step_idx - 3)
      prev_steps_objs = all_steps[start_prev:current_step_idx]
      prev_steps_data = [format_step_data(s) for s in prev_steps_objs]

      # Get Next 3
      # If index is 5, we want indices 6, 7, 8
      next_steps_objs = all_steps[current_step_idx + 1 : current_step_idx + 4]
      next_steps_data = [format_step_data(s) for s in next_steps_objs]

    # --- Build Response Object ---
    pcb_entry = PCBProcessStatus(
      assigned_pcb_id=assignment.assigned_pcb_id,
      serial_no=pcb.serialNo,
      current_step_id=current_step_id,
      #current_step_order=current_step_obj.step_order if current_step_obj else None,
      current_step_name=current_step_obj.step_name if current_step_obj else "Unknown/Not Started",
      current_step_operators=[
        OperatorInfo(
          operator_staff_no=op.operator_staff_no,
          operator_name=op.operator_name,
          operator_MRL=op.operator_MRL
        ) for op in current_step_obj.qualified_operators
      ] if current_step_obj else [],
      previous_steps=prev_steps_data,
      next_steps=next_steps_data
    )
   
    response_data.append(pcb_entry)































































































@app.get("/dashboard/analytics")
def get_dashboard_analytics(db: Session = Depends(init_db)):
    """
    MASTER DASHBOARD ANALYTICS
    Updated with specific 'Stuck PCB' definition: 
    PCBs in operator hands, not yet started or started but not completed for > 3 days.
    """

    # Helper for date parsing
    def parse_db_date(date_str):
        if not date_str: return None
        try: 
            # Handles ISO strings from your pcb_assignment/pcb_process_log tables
            return datetime.fromisoformat(str(date_str).replace("Z", ""))
        except ValueError: 
            return None

    now = datetime.now()
    three_days_ago = now - timedelta(days=3)

    # ======================================================
    # 1. PCB TYPE & STATUS DISTRIBUTION
    # ======================================================
    type_counts = (
        db.query(PcbData.Type, func.count(PcbData.ID).label("count"))
        .group_by(PcbData.Type)
        .all()
    )
    pcb_type_distribution = {(row.Type or "Unknown"): row.count for row in type_counts}

    status_counts = (
        db.query(PcbData.status, func.count(PcbData.ID).label("count"))
        .group_by(PcbData.status)
        .all()
    )
    pcb_status_distribution = {(row.status or "Unknown"): row.count for row in status_counts}

    # ======================================================
    # 2. PRODUCTION FLOW (LIVE - OPERATION WISE)
    # ======================================================
    active_assignments = db.query(PCBAssignment).filter(PCBAssignment.overall_status == "IN_PROGRESS").all()
    
    live_step_counts = {}
    for pcb in active_assignments:
        current_step = db.query(ProcessFlowMaster.step_name).filter(ProcessFlowMaster.step_order == pcb.current_step_id).first()
        stepname = current_step.step_name if current_step else "Unknown"
        live_step_counts[stepname] = live_step_counts.get(stepname, 0) + 1

    production_flow = []
    for stepname, pcb_count in live_step_counts.items():
        step_master = db.query(ProcessFlowMaster.step_order).filter(ProcessFlowMaster.step_name == stepname).first()
        operators_count = db.query(OperatorStepMapping).filter(OperatorStepMapping.flow_step_id == step_master.step_order).count() if step_master else 0
        
        production_flow.append({
            "step": stepname,
            "order": step_master.step_order if step_master else 0,
            "active_pcbs": pcb_count,
            "staff_capacity": operators_count
        })

    # ======================================================
    # 3. OVERALL OPERATION WISE
    # ======================================================
    overall_op_stats = (
        db.query(
            ProcessFlowMaster.step_name,
            func.count(PCBAssignment.assignment_id).label("pcb_count")
        )
        .outerjoin(PCBAssignment, (PCBAssignment.current_step_id == ProcessFlowMaster.flow_step_id) & 
                                  (PCBAssignment.overall_status == "IN_PROGRESS"))
        .group_by(ProcessFlowMaster.step_name)
        .all()
    )
    overall_operation_wise = [
        {"step": row.step_name, "pcb_count": row.pcb_count}
        for row in overall_op_stats
    ]

    # ======================================================
    # 4. OPERATOR LOAD & PRESENCE
    # ======================================================
    operator_presence_query = (
        db.query(
            OperatorStepMapping.operator_staff_no,
            func.count(OperatorStepMapping.operator_staff_no).label("presence_count")
        )
        .group_by(OperatorStepMapping.operator_staff_no)
        .all()
    )
    
    operator_presence_data = [{"staff_no": r.operator_staff_no, "presence_count": r.presence_count} for r in operator_presence_query]

    live_operator_counts = (
        db.query(
            PCBProcessLog.assigned_operator_staff_no,
            func.count(PCBAssignment.assignment_id).label("pcb_count")
        )
        .join(PCBAssignment, PCBAssignment.assignment_id == PCBProcessLog.assignment_id)
        .filter(
            PCBAssignment.overall_status == "IN_PROGRESS",
            PCBAssignment.current_step_id == PCBProcessLog.flow_step_id,
            PCBProcessLog.start_time.isnot(None)
        )
        .group_by(PCBProcessLog.assigned_operator_staff_no)
        .all()
    )

    op_names_query = db.query(OperatorStepMapping.operator_staff_no, OperatorStepMapping.operator_name).distinct().all()
    name_lookup = {row.operator_staff_no: row.operator_name for row in op_names_query}

    operator_load_data = []
    for row in live_operator_counts:
        staff_no = row.assigned_operator_staff_no
        operator_load_data.append({
            "staff_no": staff_no,
            "name": name_lookup.get(staff_no, staff_no),
            "pcb_count": row.pcb_count
        })

    # ======================================================
    # 5. STUCK PCBS (UPDATED DEFINITION)
    # ======================================================
    stuck_list = []
    total_active_wip_age = 0
    
    stuck_query = (
        db.query(PCBProcessLog, PcbData, ProcessFlowMaster)
        .join(PCBAssignment, PCBAssignment.assignment_id == PCBProcessLog.assignment_id)
        .join(PcbData, PcbData.PCBserialNoPartNumber == PCBAssignment.assigned_pcb_id)
        .join(ProcessFlowMaster, ProcessFlowMaster.flow_step_id == PCBProcessLog.flow_step_id)
        .filter(
            PCBAssignment.overall_status == "IN_PROGRESS",
            PCBProcessLog.process_status.in_(["PENDING", "STARTED", "PAUSED"])
        )
        .all()
    )

    for log, pcb, step in stuck_query:
        # Use start_time if started, otherwise fallback to assignment date
        ref_time_str = log.start_time
        
        if not ref_time_str:
            assignment = db.query(PCBAssignment).filter(PCBAssignment.assignment_id == log.assignment_id).first()
            ref_time_str = assignment.assignment_date if assignment else None

        ref_time = parse_db_date(ref_time_str)
        
        if ref_time:
            age_days = (now - ref_time).total_seconds() / 86400
            total_active_wip_age += age_days
            
            if age_days > 3:
                stuck_list.append({
                    "assignment_id": log.assignment_id,
                    "pcb_id": pcb.serialNo,
                    "age_days": round(age_days, 1),
                    "current_step_name": step.step_name,
                    "status": log.process_status,
                    "operator": log.assigned_operator_staff_no
                })

    # FIX: Using the same variable name consistently here
    avg_age_days = (total_active_wip_age / len(stuck_query)) if stuck_query else 0

    # ======================================================
    # 6. CYCLE TIME & ORDER TREND
    # ======================================================
    time_logs = (
        db.query(ProcessFlowMaster.step_name, PCBProcessLog.start_time, PCBProcessLog.end_time)
        .join(ProcessFlowMaster, ProcessFlowMaster.flow_step_id == PCBProcessLog.flow_step_id)
        .filter(
            PCBProcessLog.process_status == "COMPLETED",
            PCBProcessLog.start_time.isnot(None),
            PCBProcessLog.end_time.isnot(None)
        )
        .all()
    )

    step_durations = {}
    for row in time_logs:
        start = parse_db_date(row.start_time)
        end = parse_db_date(row.end_time)
        if start and end and end > start:
            duration = (end - start).total_seconds() / 60.0
            step_durations.setdefault(row.step_name, []).append(duration)

    cycle_time_data = []
    for step, durations in step_durations.items():
        cycle_time_data.append({
            "step_name": step,
            "avg_time_minutes": round(statistics.mean(durations), 2),
            "sample_size": len(durations)
        })

    daily_trend = (
        db.query(cast(PcbData.createdAt, Date).label("date"), func.count(PcbData.ID).label("count"))
        .filter(PcbData.createdAt.isnot(None))
        .group_by(cast(PcbData.createdAt, Date))
        .order_by(cast(PcbData.createdAt, Date))
        .all()
    )

    overall_task_data = []
    all_steps = db.query(ProcessFlowMaster).all()
    for s in all_steps:
        cap = db.query(OperatorStepMapping).filter(OperatorStepMapping.flow_step_id == s.step_order).count()
        overall_task_data.append({"step": s.step_name, "order": s.step_order, "staff_capacity": cap})

    return {
        "pcb_types": pcb_type_distribution,
        "pcb_statuses": pcb_status_distribution,
        "production_flow": production_flow,
        "overall_operation_wise": overall_operation_wise,
        "operator_load": operator_load_data,
        "cycle_time": cycle_time_data,
        "Overall_Task_Data": overall_task_data,
        "operator_presence": operator_presence_data,
        "batch_aging": {
            "average_wip_age_days": round(avg_age_days, 1),
            "stuck_count": len(stuck_list),
            "stuck_list": stuck_list
        },
        "order_trend": [{"date": str(r.date), "count": r.count} for r in daily_trend]
    }

  return response_data
