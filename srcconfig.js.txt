// [NEW CODE - PASTE THIS]
useEffect(() => {
  let intervalId;

  // Define a reusable fetch function inside the effect
  const fetchDashboardData = async (isBackgroundRefresh = false) => {
    // 1. Only show the loading spinner on the very first load (not on background updates)
    if (!isBackgroundRefresh) setLoading(true);

    const requestParams = { staff_no: user?.id };

    try {
      const response = await axios.get(fetchTobeAssignedPCB, { params: requestParams });
      const newData = response.data || {};

      // 2. SMART UPDATE: Compare new data with current state to prevent unnecessary re-renders
      setTaskGraph((prevData) => {
        // We compare the stringified versions. If they match, we return 'prevData'.
        // React sees the state hasn't changed and skips the re-render.
        if (JSON.stringify(prevData) !== JSON.stringify(newData)) {
          return newData; // Data Changed! React will update the screen.
        }
        return prevData; // No Change! React does nothing.
      });
      
    } catch (err) {
      console.error("Error fetching data:", err);
    } finally {
      // Only turn off loading if we turned it on (i.e., not background refresh)
      if (!isBackgroundRefresh) setLoading(false);
    }
  };

  // Logic: Only run this if we are actively looking at the dashboard
  if (currentView === "dashboard") {
    // A. Run immediately so the user sees data right away
    fetchDashboardData(false);

    // B. Set up a timer to run silently every 5 seconds
    intervalId = setInterval(() => {
      fetchDashboardData(true); // true = silent mode (no spinner)
    }, 5000);
  }

  // Cleanup: Stop the timer if the user leaves the dashboard tab
  return () => {
    if (intervalId) clearInterval(intervalId);
  };
}, [currentView]);













# done ny me @jan26

# ============================================================
# FLOW ASSIGNMENT CRUD ENDPOINTS
# ============================================================

# 1. Pydantic Model for Request Validation (Not a new table)
class FlowUpdateReq(BaseModel):
    id: Optional[int] = None  # Mapping ID (None for Create, present for Update)
    pcbProcessName: str
    assignedTo: str
    assignedToName: str
    assignedToNameInitial: str
    assignedToNameMRL: str
    assignedToNameMRLExpiry: str

# --- CREATE (Add New Record) ---
@app.post("/create_flow_mapping")
def create_flow_mapping(req: FlowUpdateReq, db: Session = Depends(get_db)):
    # Find or Create the Process Step first
    step = db.query(ProcessFlowMaster).filter(ProcessFlowMaster.step_name == req.pcbProcessName.strip()).first()
    
    if not step:
        step = ProcessFlowMaster(
            step_name=req.pcbProcessName.strip(),
            assignedToNameMRL=req.assignedToNameMRL,
            assignedToNameMRLExpiry=req.assignedToNameMRLExpiry
        )
        db.add(step)
        db.flush() # Generates flow_step_id

    # Create the Operator Mapping
    new_mapping = OperatorStepMapping(
        flow_step_id=step.flow_step_id,
        operator_staff_no=normalize_staff(req.assignedTo),
        operator_name=req.assignedToName,
        operator_initial=req.assignedToNameInitial,
        operator_MRL=req.assignedToNameMRL,
        operator_MRL_Expiry=req.assignedToNameMRLExpiry
    )
    db.add(new_mapping)
    db.commit()
    return {"message": "New entry created successfully"}

# --- UPDATE (Edit Existing Record) ---
@app.put("/update_flow_mapping")
def update_flow_mapping(req: FlowUpdateReq, db: Session = Depends(get_db)):
    # Find the existing mapping by ID
    mapping = db.get(OperatorStepMapping, req.id)
    if not mapping:
        raise HTTPException(status_code=404, detail="Mapping not found")

    # Update Operator details
    mapping.operator_staff_no = normalize_staff(req.assignedTo)
    mapping.operator_name = req.assignedToName
    mapping.operator_initial = req.assignedToNameInitial
    mapping.operator_MRL = req.assignedToNameMRL
    mapping.operator_MRL_Expiry = req.assignedToNameMRLExpiry

    # Sync Process Name in ProcessFlowMaster
    step = db.get(ProcessFlowMaster, mapping.flow_step_id)
    if step:
        step.step_name = req.pcbProcessName.strip()

    db.commit()
    return {"message": "Mapping updated successfully"}

# --- DELETE (Remove Record) ---
@app.delete("/delete_flow_mapping/{mapping_id}")
def delete_flow_mapping(mapping_id: int, db: Session = Depends(get_db)):
    mapping = db.get(OperatorStepMapping, mapping_id)
    if not mapping:
        raise HTTPException(status_code=404, detail="Mapping not found")
    
    db.delete(mapping)
    db.commit()
    return {"message": "Mapping deleted successfully"}




@app.get("/get_operator_suggestions")
def get_operator_suggestions(db: Session = Depends(get_db)):
    """Returns unique operators from the UserProfiles table."""
    # Pulling from UserProfiles ensures we see all registered employees
    users = db.query(UserProfiles).filter(
        func.upper(UserProfiles.userRole).in_(["OPERATOR", "TECHNICIAN"])
    ).all()
    
    return [{
        "staff_no": u.userID,
        "name": u.username,
        "role": u.userRole
    } for u in users]

@app.get("/get_process_suggestions")
def get_process_suggestions(db: Session = Depends(get_db)):
    """Returns unique process names from existing masters."""
    # Using distinct to avoid duplicates from different stages
    results = db.query(ProcessFlowMaster.step_name).distinct().all()
    return [r.step_name for r in results if r.step_name]
