// [NEW CODE - PASTE THIS]
useEffect(() => {
  let intervalId;

  // Define a reusable fetch function inside the effect
  const fetchDashboardData = async (isBackgroundRefresh = false) => {
    // 1. Only show the loading spinner on the very first load (not on background updates)
    if (!isBackgroundRefresh) setLoading(true);

    const requestParams = { staff_no: user?.id };

    try {
      const response = await axios.get(fetchTobeAssignedPCB, { params: requestParams });
      const newData = response.data || {};

      // 2. SMART UPDATE: Compare new data with current state to prevent unnecessary re-renders
      setTaskGraph((prevData) => {
        // We compare the stringified versions. If they match, we return 'prevData'.
        // React sees the state hasn't changed and skips the re-render.
        if (JSON.stringify(prevData) !== JSON.stringify(newData)) {
          return newData; // Data Changed! React will update the screen.
        }
        return prevData; // No Change! React does nothing.
      });
      
    } catch (err) {
      console.error("Error fetching data:", err);
    } finally {
      // Only turn off loading if we turned it on (i.e., not background refresh)
      if (!isBackgroundRefresh) setLoading(false);
    }
  };

  // Logic: Only run this if we are actively looking at the dashboard
  if (currentView === "dashboard") {
    // A. Run immediately so the user sees data right away
    fetchDashboardData(false);

    // B. Set up a timer to run silently every 5 seconds
    intervalId = setInterval(() => {
      fetchDashboardData(true); // true = silent mode (no spinner)
    }, 5000);
  }

  // Cleanup: Stop the timer if the user leaves the dashboard tab
  return () => {
    if (intervalId) clearInterval(intervalId);
  };
}, [currentView]);













# done ny me @jan26

# ============================================================
# FLOW ASSIGNMENT CRUD ENDPOINTS
# ============================================================

# 1. Pydantic Model for Request Validation (Not a new table)
class FlowUpdateReq(BaseModel):
    id: Optional[int] = None  # Mapping ID (None for Create, present for Update)
    pcbProcessName: str
    assignedTo: str
    assignedToName: str
    assignedToNameInitial: str
    assignedToNameMRL: str
    assignedToNameMRLExpiry: str

# --- CREATE (Add New Record) ---
@app.post("/create_flow_mapping")
def create_flow_mapping(req: FlowUpdateReq, db: Session = Depends(get_db)):
    # Find or Create the Process Step first
    step = db.query(ProcessFlowMaster).filter(ProcessFlowMaster.step_name == req.pcbProcessName.strip()).first()
    
    if not step:
        step = ProcessFlowMaster(
            step_name=req.pcbProcessName.strip(),
            assignedToNameMRL=req.assignedToNameMRL,
            assignedToNameMRLExpiry=req.assignedToNameMRLExpiry
        )
        db.add(step)
        db.flush() # Generates flow_step_id

    # Create the Operator Mapping
    new_mapping = OperatorStepMapping(
        flow_step_id=step.flow_step_id,
        operator_staff_no=normalize_staff(req.assignedTo),
        operator_name=req.assignedToName,
        operator_initial=req.assignedToNameInitial,
        operator_MRL=req.assignedToNameMRL,
        operator_MRL_Expiry=req.assignedToNameMRLExpiry
    )
    db.add(new_mapping)
    db.commit()
    return {"message": "New entry created successfully"}

# --- UPDATE (Edit Existing Record) ---
@app.put("/update_flow_mapping")
def update_flow_mapping(req: FlowUpdateReq, db: Session = Depends(get_db)):
    # Find the existing mapping by ID
    mapping = db.get(OperatorStepMapping, req.id)
    if not mapping:
        raise HTTPException(status_code=404, detail="Mapping not found")

    # Update Operator details
    mapping.operator_staff_no = normalize_staff(req.assignedTo)
    mapping.operator_name = req.assignedToName
    mapping.operator_initial = req.assignedToNameInitial
    mapping.operator_MRL = req.assignedToNameMRL
    mapping.operator_MRL_Expiry = req.assignedToNameMRLExpiry

    # Sync Process Name in ProcessFlowMaster
    step = db.get(ProcessFlowMaster, mapping.flow_step_id)
    if step:
        step.step_name = req.pcbProcessName.strip()

    db.commit()
    return {"message": "Mapping updated successfully"}

# --- DELETE (Remove Record) ---
@app.delete("/delete_flow_mapping/{mapping_id}")
def delete_flow_mapping(mapping_id: int, db: Session = Depends(get_db)):
    mapping = db.get(OperatorStepMapping, mapping_id)
    if not mapping:
        raise HTTPException(status_code=404, detail="Mapping not found")
    
    db.delete(mapping)
    db.commit()
    return {"message": "Mapping deleted successfully"}




@app.get("/get_operator_suggestions")
def get_operator_suggestions(db: Session = Depends(get_db)):
    """Returns unique operators from the UserProfiles table."""
    # Pulling from UserProfiles ensures we see all registered employees
    users = db.query(UserProfiles).filter(
        func.upper(UserProfiles.userRole).in_(["OPERATOR", "TECHNICIAN"])
    ).all()
    
    return [{
        "staff_no": u.userID,
        "name": u.username,
        "role": u.userRole
    } for u in users]

@app.get("/get_process_suggestions")
def get_process_suggestions(db: Session = Depends(get_db)):
    """Returns unique process names from existing masters."""
    # Using distinct to avoid duplicates from different stages
    results = db.query(ProcessFlowMaster.step_name).distinct().all()
    return [r.step_name for r in results if r.step_name]















































import React, { useState, useEffect } from 'react';
import axios from 'axios';
import {
  Box,
  Grid,
  Card,
  CardContent,
  Typography,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Chip,
  CircularProgress,
  Divider,
  Alert,
  Fade,
  Dialog,
  DialogTitle,
  DialogContent,
  Button,
  Stepper,
  Step,
  StepLabel,
  StepContent,
  Stack,
  Avatar,
  IconButton // NEW: Added for the close button on inline table
} from '@mui/material';
import {
  CheckCircle,
  Engineering,
  DateRange,
  Assessment,
  Close as CloseIcon,
  Person,
  AccessTime,
  Timer,
  VerifiedUser,
  DataObject,
  Clear // NEW: Added for the close button icon
} from '@mui/icons-material';
import { useSelector } from 'react-redux/es/exports';
import PCBTable from './PCBTable';

// --- MOCK DATA ---
const MOCK_DATA = {
  meta: { generated_at: new Date().toISOString() },
  pcb_summary: { completed_today: 45, completed: 130, inaction: 0, new: 10 },
  operational_health: { wip_pcbs: 5 },
  pcbs: [
    {
      pcb_serial: "32401$113300033357",
      serial_no: "32401",
      part_number: "113300033357",
      current_step: "AOI CORRECTION",
      current_step_order: 6,
      status: "IN_PROGRESS",
      operator: { staff_no: "E169", name: "Santosh Kumar" },
      time_in_current_step_minutes: 45
    },
    {
      pcb_serial: "32402$113300033358",
      serial_no: "32402",
      part_number: "113300033358",
      current_step: "SOLDERING",
      current_step_order: 4,
      status: "IN_PROGRESS",
      operator: { staff_no: "E170", name: "Ravi Teja" },
      time_in_current_step_minutes: 12
    }
  ]
};

const MOCK_TIMELINE_RESPONSE = {
  "Serial_No": "32401",
  "Part_Number": "62005774DA",
  "Production_Order": "83079796",
  "Description": "6 CHANNELS TR MODULE",
  "Type": "HEXA-CHILD",
  "New_Time": "2025-12-31T20:50:37.052000+05:30",
  "Inaction_time": "2025-12-31T20:50:47.291000+05:30",
  "Assigned_time": "2025-12-31T15:22:24.696002",
  "ope_log_details": [
    {
      "Task_Name": "Labelling & Traceability of the Bare PCB",
      "current_step_id": 1,
      "assignment_id": 1,
      "log_Data": { "pcb_date_code": "78", "label_gr_details": "UKYU" },
      "operator_name": "SANTOSH KUMAR",
      "operator_MRL": "MRL-6",
      "userRole": "Operator",
      "start_time": "2025-12-31T21:36:01.730000",
      "Task_Status": "Completed",
      "PCBserialNoPartNumber": "32401$62005774DA",
      "operator_staff_no": "E169",
      "userID": "E169",
      "operator_initial": "SNK",
      "operator_MRL_Expiry": "427.0",
      "userName": "Santosh Kumar",
      "end_time": "2025-12-31T21:36:10.298000"
    }
  ],
  "Durations": [8.568]
};

// --- HELPER COMPONENTS ---
const StatCard = ({ title, value, icon, subtext, color = "primary" }) => (
  <Card elevation={0} sx={{ height: '100%', borderRadius: 4, border: '1px solid #e0e0e0', boxShadow: '0 2px 10px rgba(0,0,0,0.02)', cursor: 'pointer', '&:hover': { borderColor: 'primary.main', bgcolor: '#fcfcfc' } }}>
    <CardContent sx={{ p: 3 }}>
      <Box display="flex" justifyContent="space-between" alignItems="flex-start">
        <Box>
          <Typography color="text.secondary" variant="subtitle2" fontWeight="600" sx={{ letterSpacing: 0.5, textTransform: 'uppercase', fontSize: '0.75rem' }}>{title}</Typography>
          <Typography variant="h3" fontWeight="700" color="text.primary" sx={{ mt: 1, mb: 0.5 }}>{value}</Typography>
          {subtext && <Chip label={subtext} size="small" variant="outlined" sx={{ borderRadius: 1, height: 20, fontSize: '0.65rem', fontWeight: 'bold', borderColor: '#eee', bgcolor: '#fafafa' }} />}
        </Box>
        <Box sx={{ p: 1.5, borderRadius: 3, bgcolor: `${color}.light`, color: `${color}.main`, display: 'flex', opacity: 0.9 }}>{icon}</Box>
      </Box>
    </CardContent>
  </Card>
);

const DetailItem = ({ label, value, highlight = false }) => (
  <Box mb={1.5}>
    <Typography variant="caption" display="block" color="text.secondary" sx={{ textTransform: 'uppercase', fontSize: '0.65rem', letterSpacing: 0.5 }}>{label}</Typography>
    <Typography variant="body2" fontWeight={highlight ? 700 : 500} sx={{ wordBreak: 'break-word' }}>{value || '-'}</Typography>
  </Box>
);

const ProductionLiveDashboard = ({ apiBaseUrl, user }) => {
  const [data, setData] = useState(null);
  const [tabledata,setTableData]=useState(null)
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [dialogOpen, setDialogOpen] = useState(false);
  const [selectedPcbTimeline, setSelectedPcbTimeline] = useState(null);

  // --- CHANGE 1: New state for inline table data ---
  const [activeCategoryData, setActiveCategoryData] = useState(null);
  const [activeCategoryTitle, setActiveCategoryTitle] = useState('');

  const configDetails = useSelector(state => state.MROTDataSavingReducer.configDetails);
  const DASHBOARD_API = "/supervisor/external/dashboard";
  var API3 = "/supervisor/typepcbdetails"
  var fetachTypePcbDetails = "http://192.168.0.20:2000" + API3

  if (configDetails !== undefined) {
    if (configDetails.project?.[0]?.ServerIP?.[0]?.PythonServerIP !== undefined) {
      fetachTypePcbDetails = configDetails.project[0].ServerIP[0].PythonServerIP + API3
    }
  }

  useEffect(() => {
    const fetchData = async () => {
      try {
        const dashboardUrl = apiBaseUrl + DASHBOARD_API;
        const response = await axios.get(dashboardUrl, { params: { staff_no: user?.id } });
        setData(response.data);
        setTableData(response?.data?.pcbs)
        setLoading(false);
      } catch (err) {
        console.error(err);
        setError("Live connection failed. Using local cached data.");
        setData(MOCK_DATA);
        setLoading(false);
      }
    };
    fetchData();
  }, [apiBaseUrl, user?.id]);

  const handlePcbClick = async (serialNo) => {
    try {
      const timelineUrl = `${apiBaseUrl}/timeline`;
      const response = await axios.get(timelineUrl, { params: { SerialNo: serialNo } });
      setSelectedPcbTimeline(response.data);
      setDialogOpen(true);
    } catch (err) {
      setSelectedPcbTimeline(MOCK_TIMELINE_RESPONSE);
      setDialogOpen(true);
    }
  };

  const formatTime = (isoString) => isoString ? new Date(isoString).toLocaleString() : "--:--";
  const getStatusColor = (status) => {
    switch (status) { case 'IN_PROGRESS': return 'primary'; case 'COMPLETED': return 'success'; case 'STUCK': return 'error'; default: return 'default'; }
  };

  if (loading) return <Box display="flex" justifyContent="center" p={5}><CircularProgress /></Box>;

  const handleCloseDialog = () => {
    setDialogOpen(false);
    setSelectedPcbTimeline(null);
  };

  // --- CHANGE 2: Updated handleCardClick to set data for the inline table ---
  const handleCardClick = async (title) => {
    const requestParams = { staff_no: user?.id, type: title };
    setLoading(true);
    try {
      const response = await axios.get(fetachTypePcbDetails, { params: requestParams });
      const responseData = response.data;
      
      if (Array.isArray(responseData)) {
        setActiveCategoryData(responseData);
        setActiveCategoryTitle(title);
      } else {
        setActiveCategoryData([]); // Handle empty or unexpected format
        setActiveCategoryTitle(title);
      }
    } catch (error) {
      console.error('Error fetching card data:', error);
      setActiveCategoryData(null);
    } finally {
      setLoading(false);
    }
  };

  return (
    <Box>
      {error && <Fade in={true}><Alert severity="warning" sx={{ mb: 3 }}>{error}</Alert></Fade>}

      <Grid container spacing={1} mb={4}>
        <Grid item xs={12} sm={6} md={3}>
          <Box onClick={() => handleCardClick('Completed')}>
            <StatCard title="PCB Tasks Completed Today" value={data.pcb_summary.completed_today} subtext="Count of Tasks Completed" icon={<CheckCircle fontSize="large" />} color="success" />
          </Box>
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <Box onClick={()=>handleCardClick('Assigned')}>
            <StatCard title="In-progress PCB's" value={data.operational_health.wip_pcbs} subtext="Units on Line" icon={<Engineering fontSize="large" />} color="primary" />
          </Box>
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <StatCard title="Total Pcbs Completed" value={data.pcb_summary.completed} subtext="Total Output" icon={<CheckCircle fontSize="large" />} color="success" />
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <Box onClick={()=>handleCardClick('Inaction')}>
            <StatCard title="Yet To Start" value={data.pcb_summary.inaction} subtext="Idle Units" icon={<Engineering fontSize="large" />} color="primary" />
          </Box>
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <Box onClick={() => handleCardClick('New')}>
            <StatCard title="Pcbs Present in Master List" value={data.pcb_summary.new || 0} subtext="Count of New Pcbs" icon={<CheckCircle fontSize="large" />} color="success" />
          </Box>
        </Grid>
      </Grid>

      {/* --- CHANGE 3: Inline Table Section (Conditional Rendering) --- */}
      {activeCategoryData && (
        <Fade in={true}>
          <Paper elevation={0} sx={{ borderRadius: 4, border: '1px solid #1976d2', overflow: 'hidden', mb: 4 }}>
            <Box p={2} bgcolor="#e3f2fd" display="flex" justifyContent="space-between" alignItems="center">
              <Typography variant="h6" fontWeight="800" color="primary.main">
                Detailed View: {activeCategoryTitle}
              </Typography>
              <IconButton size="small" onClick={() => setActiveCategoryData(null)}>
                <Clear color="error" />
              </IconButton>
            </Box>
            <TableContainer sx={{ maxHeight: 400 }}>
              <Table stickyHeader size="small">
                <TableHead>
                  <TableRow>
                    <TableCell sx={{ fontWeight: '700', bgcolor: '#f1f5f9' }}>Serial No</TableCell>
                    <TableCell sx={{ fontWeight: '700', bgcolor: '#f1f5f9' }}>Part Number</TableCell>
                    <TableCell sx={{ fontWeight: '700', bgcolor: '#f1f5f9' }}>Production Order</TableCell>
                    <TableCell sx={{ fontWeight: '700', bgcolor: '#f1f5f9' }}>Type</TableCell>
                    <TableCell sx={{ fontWeight: '700', bgcolor: '#f1f5f9' }}>Description</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {activeCategoryData.length > 0 ? activeCategoryData.map((item, index) => (
                    <TableRow key={item.serialNo || item.Serial_No || index} hover>
                      <TableCell>{item.Serial_No || item.serialNo || 'N/A'}</TableCell>
                      <TableCell>{item.Part_Number || item.partNumber || 'N/A'}</TableCell>
                      <TableCell>{item.Production_Order || item.productionOrder || 'N/A'}</TableCell>
                      <TableCell>{item.Type || item.type || 'N/A'}</TableCell>
                      <TableCell>{item.Description || item.description || 'N/A'}</TableCell>
                    </TableRow>
                  )) : (
                    <TableRow>
                      <TableCell colSpan={5} align="center">No PCB data available for this type.</TableCell>
                    </TableRow>
                  )}
                </TableBody>
              </Table>
            </TableContainer>
          </Paper>
        </Fade>
      )}

      {/* Main Traceability Table */}
      <Paper elevation={0} sx={{ borderRadius: 4, border: '1px solid #e0e0e0', overflow: 'hidden' }}>
        <Box p={3} borderBottom="1px solid #f0f0f0" display="flex" justifyContent="space-between"><Typography variant="h6" fontWeight="800" color="#333">Real Time Traceability</Typography><Chip label="Live Tracking" color="success" size="small" variant="outlined" /></Box>
        <TableContainer sx={{ maxHeight: 500 }}>
          <Table stickyHeader>
            <TableHead>
              <TableRow>
                {['Serial No', 'Part Number', 'Stage', 'Operator', 'Status'].map(h => <TableCell key={h} sx={{ bgcolor: '#f8f9fa', fontWeight: 'bold' }}>{h}</TableCell>)}
              </TableRow>
            </TableHead>
            <TableBody>
              {data.pcbs?.map((pcb) => (
                <TableRow key={pcb.pcb_serial} hover onClick={() => handlePcbClick(pcb.serial_no)} sx={{ cursor: 'pointer' }}>
                  <TableCell sx={{ color: 'primary.main', fontWeight: 'bold' }}>{pcb.serial_no}</TableCell>
                  <TableCell sx={{ fontFamily: 'monospace' }}>{pcb.part_number}</TableCell>
                  <TableCell>{pcb.current_step}</TableCell>
                  <TableCell>{pcb.operator?.name}</TableCell>
                  <TableCell><Chip label={pcb.status} color={getStatusColor(pcb.status)} size="small" /></TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>
        <PCBTable pcbData={tabledata}></PCBTable>
      </Paper>

      {/* Timeline Dialog (Remains for individual PCB details) */}
      <Dialog
        open={dialogOpen}
        onClose={handleCloseDialog}
        maxWidth="lg"
        fullWidth
        PaperProps={{ sx: { borderRadius: 3, minHeight: '70vh' } }}
      >
        {selectedPcbTimeline && (
          <>
            <DialogTitle sx={{ borderBottom: '1px solid #f0f0f0', pb: 2 }}>
              <Box display="flex" justifyContent="space-between" alignItems="center">
                <Box>
                  <Typography variant="h5" fontWeight="bold">PCB Production Tracker</Typography>
                  <Stack direction="row" spacing={1} alignItems="center" mt={0.5}>
                    <Chip label={`Serial Number: ${selectedPcbTimeline.Serial_No}`} color="primary" size="small" />
                    <Chip label={`Part Number: ${selectedPcbTimeline.Part_Number}`} variant="outlined" size="small" />
                  </Stack>
                </Box>
                <Button sx={{ display: 'flex', justifyContent: 'center', backgroundColor: "blue", color: "white" }} onClick={handleCloseDialog}>Close
                  <CloseIcon />
                </Button>
              </Box>
            </DialogTitle>

            <DialogContent sx={{ py: 3, px: 4, bgcolor: '#f8f9fa' }}>
              <Paper elevation={0} sx={{ p: 3, mb: 4, borderRadius: 2, border: '1px solid #e0e0e0', bgcolor: 'white' }}>
                <Grid container spacing={3}>
                  <Grid item xs={12} sm={6} md={4} lg={3}>
                    <DetailItem label="Description" value={selectedPcbTimeline.Description} highlight />
                  </Grid>
                  <Grid item xs={12} sm={6} md={4} lg={3}>
                    <DetailItem label="Production Order" value={selectedPcbTimeline.Production_Order} highlight />
                  </Grid>
                  <Grid item xs={12} sm={6} md={4} lg={3}>
                    <DetailItem label="Type" value={selectedPcbTimeline.Type} />
                  </Grid>
                  <Grid item xs={12} sm={6} md={4} lg={3}>
                    <DetailItem label="Total Steps Completed" value={selectedPcbTimeline.ope_log_details?.length || 0} />
                  </Grid>
                </Grid>
              </Paper>

              <Divider sx={{ mb: 3 }} textAlign="left">
                <Chip label="PROCESS EXECUTION TIMELINE" size="small" sx={{ fontWeight: 'bold' }} />
              </Divider>

              <Stepper orientation="vertical" activeStep={selectedPcbTimeline.ope_log_details?.length || 0} sx={{ px: 2 }}>
                {selectedPcbTimeline.ope_log_details && selectedPcbTimeline.ope_log_details.map((step, index) => (
                  <Step key={index} expanded>
                    <StepLabel StepIconProps={{ style: { color: step.Task_Status === 'Completed' ? '#2e7d32' : '#1976d2' } }}>
                      <Typography variant="h6" fontWeight="bold" sx={{ fontSize: '1rem' }}>{step.Task_Name}</Typography>
                    </StepLabel>
                    <StepContent>
                      <Paper elevation={0} sx={{ p: 0, bgcolor: 'white', border: '1px solid #ddd', borderRadius: 2, mt: 1, overflow: 'hidden' }}>
                        <Box p={2} bgcolor="#fcfcfc" borderBottom="1px solid #eee">
                          <Grid container spacing={2}>
                            <Grid item xs={12} sm={4}>
                              <Stack direction="row" spacing={1.5} alignItems="center">
                                <Avatar sx={{ width: 32, height: 32, bgcolor: '#e3f2fd', color: '#1976d2' }}><Person fontSize="small" /></Avatar>
                                <Box>
                                  <Typography variant="caption" display="block" color="text.secondary">Operator Name</Typography>
                                  <Typography variant="body2" fontWeight="600">{step.operator_name}</Typography>
                                </Box>
                              </Stack>
                            </Grid>
                            <Grid item xs={12} sm={4}>
                               <Stack direction="row" spacing={1.5} alignItems="center">
                                <Avatar sx={{ width: 32, height: 32, bgcolor: '#e8f5e9', color: '#2e7d32' }}><Timer fontSize="small" /></Avatar>
                                <Box>
                                  <Typography variant="caption" display="block" color="text.secondary">Duration</Typography>
                                  <Typography variant="body2" fontWeight="600">
                                    {selectedPcbTimeline.Durations && selectedPcbTimeline.Durations[index] !== undefined
                                      ? `${parseFloat(selectedPcbTimeline.Durations[index]).toFixed(2)}s`
                                      : 'N/A'}
                                  </Typography>
                                </Box>
                              </Stack>
                            </Grid>
                          </Grid>
                        </Box>
                        <Box p={3}>
                           <DetailItem label="Staff No" value={step.operator_staff_no} />
                           {/* Add more step details as per original code if needed */}
                        </Box>
                      </Paper>
                    </StepContent>
                  </Step>
                ))}
              </Stepper>
            </DialogContent>
          </>
        )}
      </Dialog>
    </Box>
  );
};

export default ProductionLiveDashboard;






































# --- UPDATE (Edit Existing Record) ---
@app.put("/update_flow_mapping")
def update_flow_mapping(req: FlowUpdateReq, db: Session = Depends(init_db)):
    # 1. Find the existing mapping
    mapping = db.get(OperatorStepMapping, req.id)
    if not mapping:
        # Fallback for vacant steps (HASS): Find the step and create a mapping
        step = db.query(ProcessFlowMaster).filter(ProcessFlowMaster.step_name == req.pcbProcessName.strip()).first()
        if not step:
            raise HTTPException(status_code=404, detail="Process step not found")
        
        mapping = OperatorStepMapping(flow_step_id=step.flow_step_id)
        db.add(mapping)

    # 2. Update Operator details
    mapping.operator_staff_no = normalize_staff(req.assignedTo)
    mapping.operator_name = req.assignedToName
    mapping.operator_initial = req.assignedToNameInitial
    mapping.operator_MRL = req.assignedToNameMRL
    mapping.operator_MRL_Expiry = req.assignedToNameMRLExpiry

    # 3. FIX THE BUG: Sync Process Name ONLY if it has changed
    step = db.get(ProcessFlowMaster, mapping.flow_step_id)
    new_name = req.pcbProcessName.strip()
    
    if step and step.step_name != new_name:
        # Check if the NEW name already exists elsewhere to avoid IntegrityError
        exists = db.query(ProcessFlowMaster).filter(ProcessFlowMaster.step_name == new_name).first()
        if exists:
            # If it exists, just link the mapping to that existing step ID
            mapping.flow_step_id = exists.flow_step_id
        else:
            # If it's a brand new unique name, update the current step
            step.step_name = new_name

    db.commit()
    return {"message": "Mapping updated successfully"}


