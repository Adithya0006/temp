// [NEW CODE - PASTE THIS]
useEffect(() => {
  let intervalId;

  // Define a reusable fetch function inside the effect
  const fetchDashboardData = async (isBackgroundRefresh = false) => {
    // 1. Only show the loading spinner on the very first load (not on background updates)
    if (!isBackgroundRefresh) setLoading(true);

    const requestParams = { staff_no: user?.id };

    try {
      const response = await axios.get(fetchTobeAssignedPCB, { params: requestParams });
      const newData = response.data || {};

      // 2. SMART UPDATE: Compare new data with current state to prevent unnecessary re-renders
      setTaskGraph((prevData) => {
        // We compare the stringified versions. If they match, we return 'prevData'.
        // React sees the state hasn't changed and skips the re-render.
        if (JSON.stringify(prevData) !== JSON.stringify(newData)) {
          return newData; // Data Changed! React will update the screen.
        }
        return prevData; // No Change! React does nothing.
      });
      
    } catch (err) {
      console.error("Error fetching data:", err);
    } finally {
      // Only turn off loading if we turned it on (i.e., not background refresh)
      if (!isBackgroundRefresh) setLoading(false);
    }
  };

  // Logic: Only run this if we are actively looking at the dashboard
  if (currentView === "dashboard") {
    // A. Run immediately so the user sees data right away
    fetchDashboardData(false);

    // B. Set up a timer to run silently every 5 seconds
    intervalId = setInterval(() => {
      fetchDashboardData(true); // true = silent mode (no spinner)
    }, 5000);
  }

  // Cleanup: Stop the timer if the user leaves the dashboard tab
  return () => {
    if (intervalId) clearInterval(intervalId);
  };
}, [currentView]);




























// AddProject.js - Fixed: Removed Aggressive Deduplication
import React, { useState, useEffect, useRef } from "react";
import { useSelector } from "react-redux";
import * as XLSX from "xlsx";
import axios from "axios";

// =====================
// MUI COMPONENTS
// =====================
import {
  Box,
  Typography,
  Button,
  Grid,
  IconButton,
  Table,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
  TextField,
  Checkbox,
  Snackbar,
  Alert,
  Tabs,
  Tab,
  Paper,
  TableContainer,
  Stack,
  Divider,
  Chip,
  useTheme,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  LinearProgress,
} from "@mui/material";

// =====================
// MUI ICONS
// =====================
import FilterListIcon from "@mui/icons-material/FilterList";
import AddIcon from "@mui/icons-material/Add";
import DeleteIcon from "@mui/icons-material/Delete";
import ReplayIcon from "@mui/icons-material/Replay";
import CloudUploadIcon from "@mui/icons-material/CloudUpload";
import StorageIcon from "@mui/icons-material/Storage";
import BlockIcon from "@mui/icons-material/Block";
import SaveIcon from "@mui/icons-material/Save";
import AssignmentReturnIcon from "@mui/icons-material/AssignmentReturn";
import CategoryIcon from "@mui/icons-material/Category";
import DownloadIcon from "@mui/icons-material/Download"; 


// ==========================================
// 1. CENTRALIZED CONFIGURATION
// ==========================================
const APP_CONFIG = {
  EXCEL_START_ROW: 1, 
  UPLOAD_BATCH_SIZE: 50, 

  DISPLAY_COLUMNS: ['serialNo', 'partNumber', 'productionOrder', 'quantity'],
  
  IGNORED_COLUMNS: [
    "SMT Status", "SAP Material issue", "Labour hour booking",
    "Type", "id", "_id", "status", "__v", "createdAt", "updatedAt", "source", "type"
  ],

  PROJECT_TYPES: [
    { value: "HEXA", label: "HEXA" },
    { value: "OCTA", label: "OCTA" }
  ],

  FILTER_CATEGORIES: ["All", "HEXA-CHILD", "HEXA-MAIN", "OCTA-CHILD", "OCTA-MAIN"]
};

// ==========================================
// 2. HELPER FUNCTIONS
// ==========================================

const getApiBaseUrl = (configDetails) => {
  if (configDetails?.project?.[0]?.ServerIP?.[0]?.NodeServerIP) {
    return configDetails.project[0].ServerIP[0].NodeServerIP;
  }
  if (process.env.REACT_APP_API_URL) {
    return process.env.REACT_APP_API_URL;
  }
  return "http://localhost:8082"; 
};

const expandExcelRows = (rawJson, serialCol) => {
  const expanded = [];
  
  rawJson.forEach((row, index) => {
    const val = row[serialCol]; 
    if (!val || String(val).trim() === "") return;

    const rangeMatch = String(val).match(/^(\d+)\s*-\s*(\d+)$/); 

    if (rangeMatch) {
      const start = parseInt(rangeMatch[1], 10);
      const end = parseInt(rangeMatch[2], 10);
      
      if (end >= start && (end - start) < 10000) {
        for (let i = start; i <= end; i++) {
          const newRow = { ...row }; 
          newRow[serialCol] = i.toString(); 
          newRow.id = `EXP-${index}-${i}`;  
          if (newRow["Quantity"] !== undefined) newRow["Quantity"] = 1; 
          expanded.push(newRow);
        }
        return; 
      }
    }
    expanded.push({ ...row, id: `ROW-${index}` });
  });

  return expanded;
};


// ==========================================
// MAIN COMPONENT
// ==========================================
export default function AddProject() {
  const theme = useTheme();
  const configDetails = useSelector(state => state.MROTDataSavingReducer.configDetails);
  const API_BASE = getApiBaseUrl(configDetails);

  // State
  const [tab, setTab] = useState("upload"); 
  const [selectedType, setSelectedType] = useState(APP_CONFIG.PROJECT_TYPES[0].value); 
  const [uploadSource, setUploadSource] = useState(""); 
  const [fileName, setFileName] = useState("");

  // Refs & Data
  const fullDataRef = useRef([]); 
  const [previewRows, setPreviewRows] = useState([]); 
  const [previewColumns, setPreviewColumns] = useState([]); 
  const [serialColumn, setSerialColumn] = useState(""); 
  
  // Lists
  const [masterList, setMasterList] = useState([]); 
  const [inactiveList, setInactiveList] = useState([]); 
  
  // UI
  const [isUploading, setIsUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const [masterFilter, setMasterFilter] = useState("All");
  const [inactiveFilter, setInactiveFilter] = useState("All");
  const [selectedMasterIds, setSelectedMasterIds] = useState([]);
  const [alert, setAlert] = useState({ open: false, msg: "", type: "error" }); 

  const showAlert = (msg, type) => setAlert({ open: true, msg, type });

  // 1. FETCH DATA (FIXED: REMOVED DEDUPLICATION)
  const fetchAllData = async () => {
    if (!API_BASE) return showAlert("Configuration Error: API URL not found.", "error");

    try {
      const [hexaRes, octaRes] = await Promise.all([
        axios.get(`${API_BASE}/api/pcb/history`, { params: { type: "HEXA" } }),
        axios.get(`${API_BASE}/api/pcb/history`, { params: { type: "OCTA" } })
      ]);

      // Combine Raw Data
      const allData = [...(hexaRes.data?.PcbData || []), ...(octaRes.data?.PcbData || [])];
      
      // REMOVED: The aggressive 'uniqueMap' logic that was hiding duplicates.
      // Now we process everything the backend returns.

      const processItem = (item) => {
        let compositeType = item.Type;
        if (!compositeType && item.type && item.source) {
             compositeType = `${item.type}-${item.source}`.toUpperCase();
        }
        return compositeType || "UNKNOWN";
      };

      const activeItems = [];
      const inactiveItems = [];

      allData.forEach((item, index) => {
          // Use DB ID (_id) if available, else Fallback to Serial + Index to prevent collisions
          const uniqueId = item._id || `${item.serialNo}-${index}`;

          const formatted = { 
              id: uniqueId, 
              ...item, 
              Type: processItem(item) 
          };

          if(item.status === "Inaction" || item.status === "Assigned") {
              inactiveItems.push(formatted);
          } else if (item.status === "New") {
              activeItems.push(formatted);
          }
      });

      setMasterList(activeItems);
      setInactiveList(inactiveItems);

    } catch (err) {
      console.error("Fetch Error:", err);
      showAlert(`Failed to connect to ${API_BASE}. Check VPN or Server.`, "error");
    }
  };

  useEffect(() => {
    fetchAllData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [API_BASE]); 


  // 2. EXCEL UPLOAD LOGIC
  const handleFileUpload = (e, source) => {
    const file = e.target.files[0];
    if (!file) return;

    setFileName(file.name);
    setUploadSource(source); 

    const reader = new FileReader();
    reader.onload = (evt) => {
      const buffer = new Uint8Array(evt.target.result);
      const wb = XLSX.read(buffer, { type: "array" });
      const ws = wb.Sheets[wb.SheetNames[0]];
      
      const json = XLSX.utils.sheet_to_json(ws, { range: APP_CONFIG.EXCEL_START_ROW });

      if (json.length === 0) {
        showAlert("Excel file appears empty or headers could not be found.", "error");
        return;
      }

      const originalCols = Object.keys(json[0]);
      const validCols = originalCols.filter(col => !APP_CONFIG.IGNORED_COLUMNS.includes(col));
      setPreviewColumns(validCols);

      const serialCol = validCols.find(
        (c) => c.toLowerCase().replace(/[^a-z]/g, "") === "serialnumber"
      ) || validCols.find(c => c.toLowerCase().includes("serial")); 
      
      setSerialColumn(serialCol);

      if (!serialCol) {
          showAlert("Warning: Could not auto-detect 'Serial Number' column.", "warning");
      }

      // Pre-Filter 'Ghost Rows'
      const cleanJson = json.filter(r => {
          const val = r[serialCol];
          return val !== undefined && val !== null && String(val).trim() !== "";
      });

      const processedRows = serialCol ? expandExcelRows(cleanJson, serialCol) : cleanJson.map((r, i) => ({...r, id: `ROW-${i}`}));
      fullDataRef.current = processedRows;

      const head = processedRows.slice(0, 5);
      const tail = processedRows.length > 10 ? processedRows.slice(-5) : [];
      
      if (tail.length > 0) {
         setPreviewRows([...head, { isGap: true, id: 'GAP' }, ...tail]);
      } else {
         setPreviewRows(head);
      }

      setTab("preview"); 
      showAlert(`Parsed ${cleanJson.length} valid rows.`, "success");
    };
    reader.readAsArrayBuffer(file);
    e.target.value = null; 
  };

  // 3. DOWNLOAD LOGIC
  const handleDownloadProcessed = () => {
    try {
      if (!fullDataRef.current || fullDataRef.current.length === 0) {
        return showAlert("No processed data to download.", "warning");
      }
      
      const cleanData = fullDataRef.current.map(row => {
          if (!row) return {};
          const { id, ...rest } = row; 
          return rest;
      });

      const ws = XLSX.utils.json_to_sheet(cleanData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Processed_Data");
      
      const safeName = (fileName || "PCB_Data").replace('.xlsx', '').replace('.xls', '');
      XLSX.writeFile(wb, `Processed_${safeName}.xlsx`);
      
      showAlert("Download started successfully.", "success");
    } catch (err) {
      console.error("Download failed:", err);
      showAlert("Failed to generate Excel file.", "error");
    }
  };


  // 4. SAVE LOGIC
  const saveToMaster = async () => {
    const rawData = fullDataRef.current;
    if (rawData.length === 0) return showAlert("No data to save.", "warning");

    setIsUploading(true);
    setUploadProgress(0);

    let user = JSON.parse(localStorage.getItem("user")); 
    
    // Deduplication Map (Scoped to THIS upload batch only)
    const processedMap = new Map(); 

    rawData.forEach((row) => {
      const findValue = (possibleHeaders) => {
        const keys = Object.keys(row);
        const match = keys.find(k => {
          const cleanKey = k.toLowerCase().replace(/[^a-z0-9]/g, "");
          return possibleHeaders.some(h => cleanKey === h);
        });
        return match ? row[match] : null;
      };

      let Type = "UNKNOWN";
      if(selectedType === "HEXA" && uploadSource === "child") Type = "HEXA-CHILD";
      if(selectedType === "HEXA" && uploadSource === "main") Type = "HEXA-MAIN";
      if(selectedType === "OCTA" && uploadSource === "child") Type = "OCTA-CHILD";
      if(selectedType === "OCTA" && uploadSource === "main") Type = "OCTA-MAIN";

      const pNo = findValue(["partnumber", "partno", "pno", "model"]) || "UNKNOWN";
      const sNo = row[serialColumn] || findValue(["serialno", "serialnumber", "serial"]);
      
      if(!sNo) return; 

      const payloadItem = {
        partNumber: pNo,
        serialNo: sNo,
        PCBserialNoPartNumber: `${sNo}$${pNo}`,
        productionOrder: row["Production order"],
        quantity: row["Quantity"],
        description: row["Description"],
        userID: user?.id,
        userName: user?.username,
        userRole: user?.userRole,
        userSBU: user?.sbu,
        userSBUDIV: user?.subdivision,
        Type: Type,
      };

      // Simple dedupe for this specific file upload
      if (!processedMap.has(sNo)) {
          processedMap.set(sNo, payloadItem);
      }
    });

    const cleanPayload = Array.from(processedMap.values());
    const duplicatesRemoved = rawData.length - cleanPayload.length;
    
    // Chunk & Upload
    const BATCH_SIZE = APP_CONFIG.UPLOAD_BATCH_SIZE; 
    const totalBatches = Math.ceil(cleanPayload.length / BATCH_SIZE);
    
    let successCount = 0;
    let failCount = 0;

    for (let i = 0; i < totalBatches; i++) {
        const start = i * BATCH_SIZE;
        const end = start + BATCH_SIZE;
        const batch = cleanPayload.slice(start, end);

        if (batch.length === 0) continue;

        try {
            await axios.post(`${API_BASE}/api/pcb/upload-bulk`, { 
                type: selectedType,    
                source: uploadSource,  
                csvDataJSON: batch 
            });
            successCount += batch.length;
        } catch (err) {
            console.error(`Batch ${i+1} failed`, err);
            failCount += batch.length;
        }

        setUploadProgress(Math.round(((i + 1) / totalBatches) * 100));
    }

    setIsUploading(false);
    
    let msg = `Upload Complete. Success: ${successCount}`;
    if(failCount > 0) msg += `, Failed: ${failCount}`;
    if(duplicatesRemoved > 0) msg += `. (Skipped ${duplicatesRemoved} duplicates)`;

    showAlert(msg, failCount > 0 ? "warning" : "success");

    if (successCount > 0) {
        setTab("master"); 
        setPreviewRows([]); 
        fullDataRef.current = []; 
        setUploadSource(""); 
        setFileName("");
        fetchAllData(); 
    }
  };


  // 5. ACTION HANDLERS
  const handleToggleSelect = (id) => {
    setSelectedMasterIds(prev => prev.includes(id) ? prev.filter(i => i !== id) : [...prev, id]);
  };

  const handleSelectGroup = (isChecked, categoryRows) => {
    const rowIds = categoryRows.map(r => r.id);
    setSelectedMasterIds(prev => isChecked 
        ? [...new Set([...prev, ...rowIds])] 
        : prev.filter(id => !rowIds.includes(id))
    );
  };

  const pushToInactive = () => {
    if (selectedMasterIds.length === 0) return showAlert("Select items first.", "warning");

    const selectedItems = masterList.filter(item => selectedMasterIds.includes(item.id));
    const groups = {};
    selectedItems.forEach(item => {
        const genericType = item.Type.includes("HEXA") ? "HEXA" : "OCTA";
        if (!groups[genericType]) groups[genericType] = [];
        groups[genericType].push(item.serialNo);
    });

    const promises = Object.keys(groups).map(type => 
        axios.put(`${API_BASE}/api/pcb/update-status`, { 
            type: type, 
            serialNos: groups[type], 
            status: "Inaction" 
        })
    );

    Promise.all(promises)
    .then(() => {
        fetchAllData(); 
        setSelectedMasterIds([]); 
        showAlert(`Moved ${selectedItems.length} items to Inaction List.`, "success");
        setTab("inaction"); 
    })
    .catch(() => showAlert("Server Error: Could not update status.", "error"));
  };

  const reassign = (id) => {
    const item = inactiveList.find((r) => r.id === id);
    if (!item) return;
    const type = item.Type.includes("HEXA") ? "HEXA" : "OCTA";

    axios.put(`${API_BASE}/api/pcb/update-status`, { 
        type: type, 
        serialNos: [item.serialNo], 
        status: "New" 
    })
    .then(() => {
        fetchAllData(); 
        showAlert("Item reassigned to Master Database.", "success");
        setTab("master"); 
    })
    .catch(() => showAlert("Error reassigning item.", "error"));
  };

  const getStatusColor = (status) => {
      switch ((status || "").toLowerCase()) {
          case "new": return "info";
          case "inaction": return "error";
          case "completed": return "success";
          case "wip": return "warning";
          default: return "default";
      }
  };

  const renderCategoryTables = (dataList, filter, isMaster) => {
    const categoriesToShow = filter === "All" ? APP_CONFIG.FILTER_CATEGORIES.slice(1) : [filter];

    return categoriesToShow.map((category) => {
      const categoryRows = dataList.filter(d => d.Type === category);

      if (categoryRows.length === 0) {
        if (filter !== "All") {
             return (
               <Paper key={category} variant="outlined" sx={{ p: 4, textAlign: 'center', bgcolor: '#fafafa', borderStyle: 'dashed' }}>
                  <Typography color="text.secondary">No records found for {category}.</Typography>
               </Paper>
             );
        }
        return null; 
      }

      const currentCategoryIds = categoryRows.map(r => r.id);
      const allSelected = currentCategoryIds.every(id => selectedMasterIds.includes(id));
      const someSelected = currentCategoryIds.some(id => selectedMasterIds.includes(id)) && !allSelected;

      return (
        <Paper key={category} variant="outlined" sx={{ mb: 3, overflow: 'hidden', borderColor: '#e0e0e0', borderRadius: 1 }}>
            <Box sx={{ px: 2, py: 1.5, bgcolor: '#f8f9fa', borderBottom: '1px solid #e0e0e0', display: 'flex', justifyContent: 'space-between' }}>
                <Stack direction="row" spacing={1} alignItems="center">
                    <Chip label={category} size="small" color="primary" sx={{ borderRadius: '4px', fontWeight: 700 }} />
                    <Typography variant="body2" sx={{ color: 'text.secondary', fontWeight: 500 }}>
                         <strong>{categoryRows.length}</strong> Records
                    </Typography>
                </Stack>
                {isMaster && (
                    <Stack direction="row" alignItems="center" spacing={1}>
                        <Typography variant="caption" sx={{ fontWeight: 600, color: 'text.secondary' }}>SELECT GROUP</Typography>
                        <Checkbox size="small" checked={allSelected} indeterminate={someSelected} onChange={(e) => handleSelectGroup(e.target.checked, categoryRows)} sx={{ p: 0.5 }} />
                    </Stack>
                )}
            </Box>

            <TableContainer sx={{ maxHeight: '50vh' }}>
              <Table stickyHeader size="small">
                <TableHead>
                  <TableRow>
                    {isMaster && <TableCell padding="checkbox" sx={{ bgcolor: '#fff' }} />}
                    {APP_CONFIG.DISPLAY_COLUMNS.map((col) => (
                      <TableCell key={col} sx={{ fontWeight: 700, color: '#4a5568', bgcolor: '#fff', fontSize: '0.75rem' }}>
                          {col.replace(/([A-Z])/g, ' $1').toUpperCase()}
                      </TableCell>
                    ))}
                    <TableCell sx={{ fontWeight: 700, color: '#4a5568', bgcolor: '#fff', fontSize: '0.75rem' }}>STATUS</TableCell>
                    {!isMaster && <TableCell align="right" sx={{ fontWeight: 700, color: '#4a5568', bgcolor: '#fff', fontSize: '0.75rem' }}>ACTION</TableCell>}
                  </TableRow>
                </TableHead>
                <TableBody>
                  {categoryRows.map((row) => {
                    const isSelected = selectedMasterIds.includes(row.id);
                    return (
                        <TableRow key={row.id} hover selected={isSelected}>
                        {isMaster && (
                            <TableCell padding="checkbox">
                                <Checkbox size="small" checked={isSelected} onChange={() => handleToggleSelect(row.id)} />
                            </TableCell>
                        )}
                        {APP_CONFIG.DISPLAY_COLUMNS.map((col) => (
                            <TableCell key={col} sx={{ fontSize: '0.8125rem' }}>{row[col]}</TableCell>
                        ))}
                        <TableCell>
                            <Chip label={row.status || "Unknown"} size="small" color={getStatusColor(row.status)} variant="outlined" sx={{ height: 22, fontSize: '0.7rem' }} />
                        </TableCell>
                        {!isMaster && (
                            <TableCell align="right">
                              {row.status === "Inaction" && (
                                <Button startIcon={<ReplayIcon sx={{ fontSize: 16 }} />} size="small" onClick={() => reassign(row.id)}>Restore</Button>
                              )}
                            </TableCell>
                        )}
                        </TableRow>
                    );
                  })}
                </TableBody>
              </Table>
            </TableContainer>
        </Paper>
      );
    });
  };

  const TableLegend = ({id}) => (
    <Paper variant="outlined" sx={{ mb: 2, p: 1, display: 'flex', gap: 2, borderRadius: 1, bgcolor: '#fff' }}>
        <Typography variant="caption"><strong>SERIAL NO:</strong> Unique ID</Typography>
        <Divider orientation="vertical" flexItem />
        <Typography variant="caption"><strong>PART NUMBER:</strong> Model ID</Typography>
        <Divider orientation="vertical" flexItem />
        <Typography variant="caption"><strong>QUANTITY:</strong> Batch Size</Typography>
    </Paper>
  );

  return (
    <Box sx={{ width: '100%', typography: 'body1', bgcolor: '#f4f6f8', minHeight: '100vh', p: 3 }}>
      <Paper elevation={0} sx={{ mb: 3, border: '1px solid #e0e0e0', borderRadius: 2 }}>
        <Tabs value={tab} onChange={(e, v) => setTab(v)} indicatorColor="primary" textColor="primary">
          <Tab icon={<CloudUploadIcon />} label="Import Data" value="upload" iconPosition="start" />
          <Tab icon={<AddIcon />} label="Verification" value="preview" iconPosition="start" disabled={previewRows.length === 0} />
          <Tab icon={<StorageIcon />} label="Master Database" value="master" iconPosition="start" />
          <Tab icon={<BlockIcon />} label="Hold / Inaction" value="inaction" iconPosition="start" />
        </Tabs>

        {tab === "upload" && (
            <Box sx={{ p: 4 }}>
                <Grid container justifyContent="center">
                    <Grid item xs={12} md={8} textAlign="center">
                        <FormControl size="small" sx={{ minWidth: 250, mb: 4 }}>
                            <InputLabel>Project Type</InputLabel>
                            <Select value={selectedType} label="Project Type" onChange={(e) => setSelectedType(e.target.value)}>
                                {APP_CONFIG.PROJECT_TYPES.map((t) => <MenuItem key={t.value} value={t.value}>{t.label}</MenuItem>)}
                            </Select>
                        </FormControl>

                        <Stack direction={{ xs: 'column', md: 'row' }} spacing={3}>
                            {["child", "main"].map((src) => (
                                <Box key={src} component="label" sx={{ 
                                    flex: 1, border: '1px dashed #cbd5e0', borderRadius: 2, bgcolor: '#f7fafc', p: 4, cursor: 'pointer',
                                    '&:hover': { bgcolor: '#ebf8ff', borderColor: 'primary.main' }
                                }}>
                                    <input type="file" hidden onChange={(e) => handleFileUpload(e, src)} accept=".xlsx, .xls, .csv" />
                                    {src === "child" ? <CategoryIcon color="primary" sx={{ fontSize: 32 }} /> : <StorageIcon color="secondary" sx={{ fontSize: 32 }} />}
                                    <Typography variant="subtitle2" sx={{ mt: 1, textTransform: 'capitalize' }}>{src} Excel</Typography>
                                </Box>
                            ))}
                        </Stack>
                        {fileName && <Alert severity="success" sx={{ mt: 3 }}>Ready: {fileName} ({uploadSource})</Alert>}
                    </Grid>
                </Grid>
            </Box>
        )}

        {tab === "preview" && (
            <Box>
                <Box sx={{ p: 2, borderBottom: '1px solid #e0e0e0' }}>
                    <Stack direction="row" justifyContent="space-between" alignItems="center">
                        <Typography variant="subtitle1">Total: <strong>{fullDataRef.current.length}</strong> <Typography component="span" variant="caption">(Showing 5 Start/End)</Typography></Typography>
                        <Stack direction="row" spacing={2}>
                            <Button variant="outlined" startIcon={<DownloadIcon />} onClick={handleDownloadProcessed} disabled={isUploading || fullDataRef.current.length === 0}>
                                Download Breakdown
                            </Button>
                            <Button variant="contained" startIcon={<SaveIcon />} onClick={saveToMaster} disabled={isUploading}>
                                {isUploading ? "Uploading..." : "Commit to Database"}
                            </Button>
                        </Stack>
                    </Stack>
                    {isUploading && <LinearProgress variant="determinate" value={uploadProgress} sx={{ mt: 1 }} />}
                </Box>
                <TableContainer sx={{ maxHeight: '60vh' }}>
                    <Table stickyHeader size="small">
                        <TableHead>
                            <TableRow>
                                <TableCell>#</TableCell>
                                {previewColumns.map(c => <TableCell key={c} sx={{ fontWeight: 700 }}>{c.toUpperCase()}</TableCell>)}
                            </TableRow>
                        </TableHead>
                        <TableBody>
                            {previewRows.map((row, i) => (
                                row.isGap ? 
                                <TableRow key="gap"><TableCell colSpan={100} align="center" sx={{ bgcolor: '#eee' }}>... {fullDataRef.current.length - 10} MORE RECORDS ...</TableCell></TableRow> :
                                <TableRow key={row.id}>
                                    <TableCell>{i < 5 ? i + 1 : fullDataRef.current.length - (previewRows.length - i) + 1}</TableCell>
                                    {previewColumns.map(c => <TableCell key={c}>{row[c]}</TableCell>)}
                                </TableRow>
                            ))}
                        </TableBody>
                    </Table>
                </TableContainer>
            </Box>
        )}

        {(tab === "master" || tab === "inaction") && (
            <Box sx={{ p: 3, bgcolor: '#f9fafb' }}>
                <Box sx={{ mb: 2, display: 'flex', justifyContent: 'space-between' }}>
                    <Stack direction="row" spacing={2} alignItems="center">
                        <FilterListIcon color="action" />
                        <FormControl size="small" sx={{ minWidth: 200 }}>
                            <Select value={tab === "master" ? masterFilter : inactiveFilter} onChange={(e) => tab === "master" ? setMasterFilter(e.target.value) : setInactiveFilter(e.target.value)}>
                                {APP_CONFIG.FILTER_CATEGORIES.map(c => <MenuItem key={c} value={c}>{c}</MenuItem>)}
                            </Select>
                        </FormControl>
                    </Stack>
                    {tab === "master" && (
                        <Button variant="contained" color="warning" startIcon={<AssignmentReturnIcon />} onClick={pushToInactive} disabled={selectedMasterIds.length === 0}>
                            Move Selected ({selectedMasterIds.length})
                        </Button>
                    )}
                </Box>
                <TableLegend id={tab} />
                {renderCategoryTables(
                    tab === "master" ? masterList : inactiveList, 
                    tab === "master" ? masterFilter : inactiveFilter, 
                    tab === "master"
                )}
            </Box>
        )}
      </Paper>
      <Snackbar open={alert.open} autoHideDuration={3000} onClose={() => setAlert({ ...alert, open: false })} anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}>
        <Alert severity={alert.type} variant="filled" onClose={() => setAlert({ ...alert, open: false })}>{alert.msg}</Alert>
      </Snackbar>
    </Box>
  );
}

